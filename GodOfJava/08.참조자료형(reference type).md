# 참조자료형(reference type)
기본 자료형(boolean, char, byte, short, int, long, float, double) 8개를 제외한 나머지 타입은 모두 참조 자료형이다.  
데이터 값을 그대로 저장하는 기본 자료형과는 다르게 참조 자료형은 메모리 상에서 데이터가 저장된 주소, 즉 참조값을 저장하기에 참조 자료형이라 불린다.  
자바에서의 참조 자료형은 메모리 상에 동적으로 생성된 오브젝트의 참조값을 저장한다.  
그리고 참조 자료형은 자바에서 기본적으로 정의되어있는 기본 자료형과는 다르게 미리 정의되어 있지 않으며, 필요에 따라 클래스로 정의된다.

# 생성자(constructor)
생성자란 객체를 생성할 때 호출하는 메소드 비슷한 것을 말한다. 주로 일반 멤버변수의 초기화나 객체를 생성할때 실행하는 작업을 정리한다.

<생성자의 특징>
- 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다.
- 생성자는 초기화를 위한 데이터를 파라미터로 전달받을 수 있다.
- 객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다.  
   (오버로딩(overloading)이 가능하다.)
- 생성자의 이름은 클래스 이름과 같아야한다.

### <생성자 vs void 메소드 차이점>  
형태가 retrun값이 없는 void 메소드와 비슷하게 생겼다
차이점 : 이름과 역할
이름 : 생성자는 class명과 똑같아야하고 메소드는 달라야한다.
역할 : 메소드는 다양한 기능을 담당하지만 생성자는 멤버변수의 초기화를 담당한다.

별도의 생성자를 만들지 않고 컴파일 시키면 컴파일러가 자동으로 기본 생성자를 만들어 주는데 이를 기본 생성자라고 한다.  
기본 생성자는 파라미터를 전달 받지 않기 때문에 빈 객체를 생성한다.
```java
public class BasicConstructor {

	String name;
	int age;
	
	//public BasicConstructor() {} //생략된 기본 생성자
	
	public static void main(String[] args) {
	
		//new연산자가 BasicConstructor()를 호출하면 컴파일러가 자동으로 기본생성자를 만든다
		BasicConstructor person = new BasicConstructor();
		
		//기본생성자이므로 외부에서 객체의 멤버 변수를 설정해줘야한다
		person.name ="홍길동";
		person.age =77;
	}
}
```
만약 파라미터를 가지고 있는 생성자를 정의해줬다면 기본 생성자도 함께 정의해 주어야한다.  
(정의해주지 않으면 컴파일 오류남! 기본 생성자는 아무런 생성자가 정의 되지 않았을때만 자동으로 생성해주기 때문이다.)

## 예약어 this 
this 예약어는 생성자와 메소드 안에서 사용할 수 있다.  

<this 예약어 용법>
- this. : 현재 객체를 참조하기 위한 용도
- this() : 다른 생성자를 호출하는 용도

### 멤버변수를 참조하는 this.멤버변수명
매개 변수와 멤버 변수의 이름이 같으면 컴파일러는 두 변수를 구분해 내지 못한다. 따라서 this 예약어를 통해서 이를 구분해 준다.
```java
public class ThisPerson {
	
	String name;
	int age;
	
	ThisPerson(String name, int age){
		this.name = name; //멤버 변수 앞에 this를 붙여준다.
		this.age = age;
	}
}
```
# 메소드 오버로딩(overloading)
메소드의 이름을 같도록 하고 , 매개 변수만을 다르게 하는 것을 오버로딩이라고 한다.(생성자도 오버로딩이 가능하다.)

# static 메소드와 일반 메소드의 차이
static 메소드는 메소드 앞에 static가 붙은 메소드이다. 객체 생성 없이 호출이 가능한 메소드이다.  
static 메소드와 인스턴스 메소드의 차이는 인스턴스 변수 사용 유무로 나뉜다.

### 인스턴스 메소드
- 인스턴스 생성 후, '참조 변수.메소드 명()'으로 호출한다.
- 인스턴스 멤버와 관련된 작업을 한다.
- 메소드 내에서 인스턴스 변수를 사용할 수 있다.
- 인스턴스 변수를 이용해서 작업을 하므로 변수의 묶음인 객체를 생성해야 인스턴스 메소드를 호출할 수 있다.

```java
Exam ex = new Exam(); 
ex.example = "예시";
```
### static 메소드(클래스 메소드)
- 객체 생성 없이 '클래스 명.메소드 명()'으로 호출이 가능하다.
- 인스턴스 멤버와 관련되지 않은 작업을 한다.
- 메소드 내에서 인스턴스 변수를 사용할 수 없다.
- 인스턴스 메소드와 달리 인스턴스 변수가 필요 없으므로 객체를 생성하지 않고도 호출할 수 있다.

```java
Math.random()
```
#### ※ 호출의 차이  
static 메소드는 인스턴스 변수를 호출할 수 없지만 인스턴스 메소드는 static 변수를 호출할 수 있다.  
static 메소드는 인스턴스 메소드를 호출할 수 없지만 인스턴스 메소드는 static 메소드를 호출할 수 있다.  

왜 static 메소드는 인스턴스 멤버(인스턴스 변수, 인스턴스 메소드)를 사용할 수 없는가?
-> 인스턴스 메소드를 이용하려면 인스턴스 변수를 사용하므로 객체 생성이 필요하다.  
그러나 static 메소드는 항상 호출이 가능해야하는데, 객체가 있을지 없을지 모르기 때문이다.  
static 메소드끼리, 인스턴스 메소드끼리는 호출이 가능하다.  